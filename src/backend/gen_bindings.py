#!/bin/python3

import re
import sys
import subprocess
import tempfile
import json
from llvmlite import binding

## gen_bindings.py
## Provides macros to include forward
## declarations from C header files


class BindingGenError(Exception):
    pass


# Used as a prefix to global variables created for binding generation
VAR_PREFIX = "_bindingGen_"


class BindingGenerator:
    def __init__(self, headers, functions, structs, typedefs):
        # List of headers to be included
        self.headers = headers
        # List of desired function prototypes
        self.functions = functions
        # Mapping of desired struct name -> struct definition
        self.structs = structs
        # List of desired typedefs
        self.typedefs = typedefs

        # The LLVM module containing the signatures we want
        self.llmod = None
        # The AST of the C program generated by Clang
        self.c_ast = None

    def gen_cprog(self):
        """Generate the C program for binding generation"""

        ## C code to produce external side-effects
        # Functions
        function_pins = "\n".join(
            f"    pin_function({func});" for func in self.functions
        )
        # Structs
        struct_pins = "\n".join(
            f"    {{ struct {struct} var; pin_function(&var); }}"
            for struct in self.structs
        )
        # Typedefs
        typedef_pins = "\n".join(
            f"{alias} {VAR_PREFIX}{alias};" for alias in self.typedefs
        )

        ## Header inclusion
        header_includes = "\n".join(f'#include "{header}"' for header in self.headers)

        return "\n".join(
            (
                header_includes,
                typedef_pins,
                "extern void pin_function(void *);",
                "int main () {",
                function_pins,
                struct_pins,
                "}",
            )
        )

    def get_clisp_type(self, typ):
        """Map an LLVM type (TypeRef) to a C-Lisp type"""

        ## Handlers for each type kind
        ## Each takes a string as an argument
        def get_clisp_int_type(typ):
            """'iXX' -> 'intXX'"""
            width = typ[1:]
            if width == "32":
                width = ""
            return f"int{width}"

        def get_clisp_ptr_type(typ):
            """'XX*' -> ['ptr', 'XX']"""
            pointee = typ[:-1]
            return ["ptr", self.get_clisp_type(pointee)]

        def get_clisp_struct_type(typ):
            """'%struct.XX' -> ['struct', 'XX']"""
            return ["struct", typ.replace("%struct.", "")]

        type_map = (
            ## Type regex -> handler function
            (r"i[0-9]+", get_clisp_int_type),
            (r".*\*", get_clisp_ptr_type),
            (r"float|void", lambda typ: str(typ)),
            (r"%struct\..*", get_clisp_struct_type),
        )
        typ_str = str(typ)
        for pattern, handler in type_map:
            if re.fullmatch(pattern, typ_str):
                return handler(typ_str)
        raise BindingGenError(f"Unknown type: {typ}")

    def gen_prototype(self, fn_ref):
        """Generate the prototype of fn_ref (LLVMLite ValueRef)"""
        # fn_ref is a function pointer; fn_type is the function's type
        fn_type = fn_ref.type.element_type
        type_elements = [self.get_clisp_type(elem) for elem in fn_type.elements]
        return [
            "define",
            [
                [fn_ref.name, type_elements[0]],
                *([f"arg-{t}", typ] for t, typ in enumerate(type_elements[1:])),
            ],
        ]

    def get_decl_ast(self, decl_name):
        """
        Locate and return the declaration of `decl_name` in the C AST.
        `decl_name` is assumed to be at the top level of the C program.
        """
        for decl in self.c_ast["inner"]:
            if "name" in decl and decl["name"] == decl_name:
                return decl
        raise BindingGenError(
            f"Cannot find declaration for {decl_name} in the AST dump"
        )

    def gen_struct(self, struct_ref):
        """Generate a struct type corresponding to struct_ref (LLVMLite TypeRef)"""
        assert struct_ref.name.startswith("struct.")
        struct_name = struct_ref.name.replace("struct.", "")

        # Get struct field types from the LLVM module
        field_types = [self.get_clisp_type(elem) for elem in struct_ref.elements]

        # Get struct field names from the C AST
        field_names = []
        struct_ast = self.get_decl_ast(struct_name)
        assert struct_ast["tagUsed"] == "struct"
        for field in struct_ast["inner"]:
            if field["kind"] == "FieldDecl":
                field_names.append(field["name"])

        assert len(field_names) == len(field_types)
        return [
            "define-struct",
            struct_name,
            *zip(field_names, field_types),
        ]

    def gen_typedef(self, alias):
        """Resolve the type that `alias` is typedef'ed to"""
        alias_var = self.llmod.get_global_variable(f"{VAR_PREFIX}{alias}")
        alias_type = self.get_clisp_type(alias_var.type.element_type)
        add_macro(alias, alias_type)
        # return alias_type

    def build(self, debug=False):
        tmpdir = tempfile.TemporaryDirectory()
        cprog = f"{tmpdir.name}/binding.c"
        llprog = f"{tmpdir.name}/binding.ll"

        # Generate C program that uses desired objects
        cprog_file = open(cprog, "w")
        cprog_str = self.gen_cprog()
        if debug:
            print_prog(cprog_str)
        cprog_file.write(cprog_str)
        cprog_file.close()

        # Compile to LLVM and save the JSON AST dump
        res = subprocess.run(
            f"clang -I./ -o{llprog} -emit-llvm -S {cprog}".split(),
            capture_output=True,
            text=True,
        )
        if res.returncode:
            print(str(res.stderr), file=sys.stderr)
            raise BindingGenError("Compilation to LLVM IR by clang failed")
        c_ast_json = subprocess.run(
            f"clang -Xclang -ast-dump=json -fsyntax-only {cprog}".split(),
            capture_output=True,
            text=True,
            check=True,
        ).stdout
        self.c_ast = json.loads(c_ast_json)

        # Parse the LLVM IR and get a handle to the module
        llprog_file = open(llprog)
        llprog_str = llprog_file.read()
        if debug:
            print_prog(llprog_str)
        self.llmod = binding.parse_assembly(llprog_str)
        llprog_file.close()

        # Cleanup
        tmpdir.cleanup()

    def include(self, debug=False):
        """
        Implementation of `include` macro
        """
        self.build(debug)
        # Process all structs that are depended on, not just the desired ones
        struct_definitions = [
            self.gen_struct(struct) for struct in self.llmod.struct_types
        ]
        for name in self.typedefs:
            self.gen_typedef(name)
        return [
            # Prototypes of desired functions
            *(
                self.gen_prototype(self.llmod.get_function(func))
                for func in self.functions
            ),
            # Struct type definitions
            *struct_definitions,
        ]


def include(headers, functions, structs, typedefs, debug=False):
    """
    Macro to include `functions` and `structs` from `headers`
    Example usage:
        ; Generates declarations for `malloc` and `puts`, having included stdio.h and stdlib.h
        ,(include (stdio.h stdlib.h) (malloc puts))
    """
    binding_generator = BindingGenerator(headers, functions, structs, typedefs)
    return binding_generator.include(debug)


# Utility functions
def print_prog(prog):
    print("====", "    " + prog.replace("\n", "\n    "), "====", sep="\n")


def add_macro(name, val):
    globals()[name] = val


if __name__ == "__main__":
    headers = input("Space-delimited list of headers to include: ").split()
    functions = input("Space-delimited list functions to parse: ").split()
    structs = input("Space-delimited list structs to parse: ").split()
    typedefs = input("Space-delimited list typedefs to parse: ").split()
    # binding_generator = BindingGenerator(headers, functions, structs, typedefs)
    # print(binding_generator.include(debug=True))
    print(include(headers, functions, structs, typedefs, debug=True))
